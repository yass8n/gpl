gpl.cpp::main()
  input file(tests/t802.gpl)
  random seed(42)
  read_keypresses_from_standard_input(false)
  dump_pixels(false)
  symbol_table(true)
  print_symbol_table(true)
  graphics(false)

gpl.cpp::main() Calling yyparse()

ST
creating a new T INT CONSTANT with value 1
if the lookup results in false, insert a in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on a
 returning m_int value ->1
ST
creating a new T INT CONSTANT with value 2
if the lookup results in false, insert b in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on b
 returning m_int value ->2
ST
creating a new T INT CONSTANT with value 3
if the lookup results in false, insert c in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on c
 returning m_int value ->3
ST
creating a new T INT CONSTANT with value 4
if the lookup results in false, insert d in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on d
 returning m_int value ->4
ST
creating a new T INT CONSTANT with value 5
if the lookup results in false, insert e in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on e
 returning m_int value ->5
ST
creating a new T INT CONSTANT with value 6
if the lookup results in false, insert f in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on f
 returning m_int value ->6
ST
creating a new T INT CONSTANT with value 7
if the lookup results in false, insert g in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on g
 returning m_int value ->7
ST
creating a new T INT CONSTANT with value 8
if the lookup results in false, insert h in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on h
 returning m_int value ->8
ST
creating a new T INT CONSTANT with value 9
if the lookup results in false, insert i in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on i
 returning m_int value ->9
ST
creating a new T INT CONSTANT with value 10
if the lookup results in false, insert j in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on j
 returning m_int value ->10
ST
creating a new T INT CONSTANT with value 11
if the lookup results in false, insert k in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on k
 returning m_int value ->11
ST
creating a new T INT CONSTANT with value 12
if the lookup results in false, insert l in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on l
 returning m_int value ->12
ST
creating a new T INT CONSTANT with value 13
if the lookup results in false, insert m in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on m
 returning m_int value ->13
ST
creating a new T INT CONSTANT with value 14
if the lookup results in false, insert n in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on n
 returning m_int value ->14
ST
creating a new T INT CONSTANT with value 15
if the lookup results in false, insert o in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on o
 returning m_int value ->15
ST
creating a new T INT CONSTANT with value 16
if the lookup results in false, insert p in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on p
 returning m_int value ->16
ST
creating a new T INT CONSTANT with value 17
if the lookup results in false, insert q in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on q
 returning m_int value ->17
ST
creating a new T INT CONSTANT with value 18
if the lookup results in false, insert r in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on r
 returning m_int value ->18
ST
creating a new T INT CONSTANT with value 19
if the lookup results in false, insert s in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on s
 returning m_int value ->19
ST
creating a new T INT CONSTANT with value 20
if the lookup results in false, insert t in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on t
 returning m_int value ->20
ST
creating a new T INT CONSTANT with value 21
if the lookup results in false, insert u in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on u
 returning m_int value ->21
ST
creating a new T INT CONSTANT with value 22
if the lookup results in false, insert v in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on v
 returning m_int value ->22
ST
creating a new T INT CONSTANT with value 23
if the lookup results in false, insert w in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on w
 returning m_int value ->23
ST
creating a new T INT CONSTANT with value 24
if the lookup results in false, insert x in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on x
 returning m_int value ->24
ST
creating a new T INT CONSTANT with value 25
if the lookup results in false, insert y in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on y
 returning m_int value ->25
ST
creating a new T INT CONSTANT with value 26
if the lookup results in false, insert z in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on z
 returning m_int value ->26
ST
making a new variable in gpl.y and passing in n
now in var constructor and its in the table -> n
