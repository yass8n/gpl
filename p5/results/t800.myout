gpl.cpp::main()
  input file(tests/t800.gpl)
  random seed(42)
  read_keypresses_from_standard_input(false)
  dump_pixels(false)
  symbol_table(true)
  print_symbol_table(true)
  graphics(false)

gpl.cpp::main() Calling yyparse()

ST
creating a new T INT CONSTANT with value 1
if the lookup results in false, insert a in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on a
 returning m_int value ->1
ST
creating a new T INT CONSTANT with value 2
if the lookup results in false, insert b in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on b
 returning m_int value ->2
ST
creating a new T INT CONSTANT with value 3
if the lookup results in false, insert c in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on c
 returning m_int value ->3
ST
creating a new T INT CONSTANT with value 4
if the lookup results in false, insert d in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on d
 returning m_int value ->4
ST
creating a new T INT CONSTANT with value 5
if the lookup results in false, insert e in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on e
 returning m_int value ->5
ST
creating a new T INT CONSTANT with value 6
if the lookup results in false, insert f in symbol table after creating the symbol for it ...it wasnt in the table... and its value was INT  calling evaluate int on f
 returning m_int value ->6
ST
making a new variable in gpl.y and passing in a
now in var constructor and its in the table -> a
